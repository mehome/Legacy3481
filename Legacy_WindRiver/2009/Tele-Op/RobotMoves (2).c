#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     HTDIR,               sensorLowSpeed)
#pragma config(Sensor, S3,     lightSensor,         sensorLightActive)
#pragma config(Sensor, S4,     sonarSensor,         sensorSONAR)
#pragma config(Motor,  motorA,          motorA,        tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorB,          motorB,        tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          motorC,        tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorNormal, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorNormal, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     motorJ,        tmotorNormal, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorK,        tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma config(Sensor, S1,     HTDIR,               sensorLowSpeed)

// Brandeis lower-level robot move functions.
// use for both autonomous and teleop modes


#include "HTDIR-driver.h"

// global variables
long encoderD;  // global makes it easier to watch value change in debug window
long encoderE;
long nNumbCyles;  //used by HTDIR
long nInits = 0;  //used by HTDIR
string sTextLines[8];
int _dirDC = 0;
int _dirAC = 0;
int dcS1, dcS2, dcS3, dcS4, dcS5 = 0;
int acS1, acS2, acS3, acS4, acS5 = 0;
// the default DSP mode is 1200 Hz.


// function prototypes
void ErrorNotifyI2C();
void initializeHTDIRSensor();
void getHTIRDirection();
void displayText(int nLineNumber, string cChar, int nValueDC, int nValueAC);
void driveStop();
void driveContinuous(int speed);  // +speed forward; -speed backward
void driveDistance(int speed, long distance);  // +speed forward; -speed backward
void turnRightLeft(int speed);
void turnRight(int speed);
void turnLeft(int speed);

task main ()
{
  initializeDriveMotors();
  motor[motorJ]=10;
  robotMove1bs();
  //shooting
  //robotMove2as();
}

void robotMove1bs()
{
initializeDriveMotors();
while(nMotorEncoder[motorD]<300)
{
motor[motorD] = 100;
motor[motorE] = 100;
}

/*();
while(nMotorEncoder[motorE]<200)
motor[motorD] = 0;
motor[motorE] = 100;

initializeDriveMotors();
while(nMotorEncoder[motorD]<150)
motor[motorD] = 100;
motor[motorE] = 100;

initializeDriveMotors();
while(nMotorEncoder[motorD]<
motor[motorD] = 0;
motor[motorE] = 0;
}

void robotMove1as()
{
initializeDriveMotors();
motor[motorD] = -100;
motor[motorE] = -100;
//wait10Msec(75)

initializeDriveMotors();
motor[motorD] = 0;
motor[motorE] = 100;
//wait10Msec(300)

initializeDriveMotors();
motor[motorD] = 100;
motor[motorE] = 100;
//wait10Msec(275)

initializeDriveMotors();
motor[motorD] = 0;
motor[motorE] = 100;
//wait10Msec(50)

initializeDriveMotors();
motor[motorD] = 50;
motor[motorE] = 50;
//wait10Msec(50)

//motor

//motor

//motor

}
void openArms()
{
  while(nMotorEncoder[motorF] <= 600)
  {
    motor[motorF] = 70;
  }
  motor[motorF] = 0;
  while(nMotorEncoder[motorG] <= 600)
  {
    motor[motorG] = 70;
  }
  motor[motorG] = 0;
}
void closeArms()
{
  while(nMotorEncoder[motorF] > 0)
  {
    motor[motorF] = -70;
  }
  motor[motorF] = 0;
  while(nMotorEncoder[motorG] > 0)
  {
    motor[motorG] = -70;
  }
  motor[motorG] = 0;
}

void initializeHTDIRSensor()
{
    tHTDIRDSPMode _mode = DSP_1200;
    eraseDisplay();
    nNumbCyles = 0;
    ++nInits;
    while (true)
    {
      if ((nNumbCyles & 0x04) == 0)
        nxtDisplayTextLine(0, "Initializing...");
      else
        nxtDisplayTextLine(0, "");
      nxtDisplayCenteredBigTextLine(1, "IR Seekr");

      // set the DSP to the new mode
      if (HTDIRsetDSPMode(HTDIR, _mode))
        break; // Sensor initialized

      ++nNumbCyles;
      PlaySound(soundShortBlip);
      nxtDisplayTextLine(4, "Inits: %d / %d", nInits, nNumbCyles);
      nxtDisplayCenteredTextLine(6, "Connect Sensor");
      nxtDisplayCenteredTextLine(7, "to Port S2");
      wait1Msec(100);
    }

    eraseDisplay();
    for (int i = 0; i < 8; ++i)
      sTextLines[i] = "";
}

// Minimize LCD screen flicker by only updating LCD when data has changed
void displayText(int nLineNumber, string cChar, int nValueDC, int nValueAC)
{
  string sTemp;

  StringFormat(sTemp, "%4d  %4d", nValueDC, nValueAC);
  // Check if the new line is the same as the previous one
  // Only update screen if it's different.
  if (sTemp != sTextLines[nLineNumber])
  {
    string sTemp2;

    sTextLines[nLineNumber] = sTemp;
    StringFormat(sTemp2, "%s:  %s", cChar, sTemp);
    nxtDisplayTextLine(nLineNumber, sTemp2);
  }
}


void initializeDriveMotors()
{
  nMotorEncoder[motorD] = 0;
  nMotorEncoder[motorE] = 0;
}

void initializeArmMotors()
{
  nMotorEncoder[motorF] = 0;
  nMotorEncoder[motorG] = 0;
}


void driveStop()
{
  motor[motorD] = 0;
  motor[motorE] = 0;

}

void driveContinuous()//int speed)   +speed forward; -speed backward
{
  motor[motorD] = 100; //turn motor D on, which controls motor E at the same power
  motor[motorE] = 100;
}

void driveDistance(int speed, long distance)  // +speed forward; -speed backward
{  //WARNING:  limited to 15000 counts
  nMotorEncoder[motorE] = 0;
  nMotorEncoder[motorD] = 0;
  nMotorEncoderTarget[motorD] = distance; //set motor's target position
  motor[motorD] = speed; //turn motor D on, which controls motor E at same power
  motor[motorE] = speed;
  while(nMotorRunState[motorD] != runStateIdle)//while motorB is not in an idle position
  {
   //continue to monitor nMotorEncoderTarget's target position
    encoderD = nMotorEncoder[motorD];  //update debug screen
    encoderE = nMotorEncoder[motorE];
  }
  motor[motorD] = 0;  // turn the motors off.
  motor[motorE] = 0;
}

void turnRightLeft(int speed) //this works for either right or left, just change sign +/- of speed
{
  // Tetrix encoder has 1440 counts per revolution
  const int TURNCOUNT = 1500; //change this value to get a proper turn
//  nSyncedMotors = synchDE; //motor D is the master, motor E is the slave
//  nSyncedTurnRatio = -100; //motors move at 100% alignment to each other, opposite directions
  nMotorEncoder[motorD] = 0;
  nMotorEncoderTarget[motorD] = TURNCOUNT; //set motor's target position
  motor[motorE] = speed; //turn motor D on, which controls motor E at same power
  motor[motorD] = -speed;
  while(nMotorRunState[motorD] != runStateIdle)//while motorB is not in an idle position
  {
   //continue to monitor nMotorEncoderTarget's target position
    encoderD = nMotorEncoder[motorD];  //update debug screen
    encoderE = nMotorEncoder[motorE];
  }
  motor[motorD] = 0;  // turn the motors off.
  motor[motorE] = 0;
}

void turnRight(int speed)
{
  turnRightLeft(speed);
}

void turnLeft(int speed)
{
  turnRightLeft(-speed);
}

void driveToBlackLine(int speed)
{
  int threshold = 44;

	while(SensorValue[lightSensor] > threshold)
	{
		driveContinuous(speed);
	}
  driveStop();
}

void driveToSonarOffset (int offset, int speed)
{
	while(SensorValue(sonarSensor) > offset)
	{
		driveContinuous(speed);
	}
  driveStop();
}

/*
void driveToTouch (int speed)
{
	while(SensorValue(touchSensor) == 0)
	{
		driveContinuous(speed);
	}
  driveStop();
}
*/

void ErrorNotifyI2C()
{
  PlayTone(5000,100);
  PlayTone(10000,100);
  //break; // I2C read error occurred
}


void getHTIRDirection()
{

        // Read the current non modulated signal direction
      _dirDC = HTDIRreadDCDir(HTDIR);
      if (_dirDC < 0)
      ErrorNotifyI2C();

      // read the current modulated signal direction
      _dirAC = HTDIRreadACDir(HTDIR);
      if (_dirAC < 0)
      ErrorNotifyI2C();

      // Read the individual signal strengths of the internal sensors
      // Do this for both unmodulated (DC) and modulated signals (AC)
      if (!HTDIRreadAllDCStrength(HTDIR, dcS1, dcS2, dcS3, dcS4, dcS5))
      ErrorNotifyI2C();
      if (!HTDIRreadAllACStrength(HTDIR, acS1, acS2, acS3, acS4, acS5 ))
      ErrorNotifyI2C();
}


void testIRSeeker()
{
  while(1 == 1)
  {
//    if(SensorValue[IRSeeker2] == 5)
    {
      motor[motorD] = 50;
      motor[motorE] = 50;
    }

//    if(SensorValue[IRSeeker2] > 5)
    {
      motor[motorD] = -50;
      motor[motorE] = 50;
    }

//    if(SensorValue[IRSeeker2] < 5)
    {
      motor[motorD] = 50;
      motor[motorE] = -50;
    }
  }
}

/*
void findThreshold()
{
  int lightValue;
  int darkValue;
  int sumValue;
  int thresholdValue;
  int countValue = 0;
  int lastSeen;

  /*
	while(SensorValue(touchSensor) == 0)
	{
		nxtDisplayStringAt(0,31,"Read Light Now");
	}

	lightValue = SensorValue(lightSensor);
	nxtDisplayStringAt(0,31,"Read Light Now");

	int lighT

	wait1Msec(1000);

	while(SensorValue(touchSensor) == 0)
	{
		nxtDisplayStringAt(0,31,"Read Dark Now");
	}

	darkValue = SensorValue(lightSensor);

	sumValue = lightValue + darkValue;
	thresholdValue = sumValue/2;
}
*/

/*
void lineFollow()
{
  float rpmD;
  float rpmE;
  long moveD;
  long moveE;
  while (true)
  {
    nMotorEncoder[motorD] = 0;
    nMotorEncoder[motorE] = 0;
    time1[T1] = 0;
    while (time1[T1] < 1000)
    {
      motor[motorD] = 100;
	    motor[motorE] = 10;
	    wait1Msec(10);
	    motor[motorD] = 10;
	    motor[motorE] = 100;
	    wait1Msec(10);
	  }
    moveD = nMotorEncoder[motorD];
    moveE = nMotorEncoder[motorE];
    rpmD = ((float) moveD) / 1440 * 60;
    rpmE = ((float) moveE) / 1440 * 60;
  }
}
*/
