#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S2,     touchSensor,         sensorTouch)
#pragma config(Sensor, S3,     lightSensor,         sensorLightActive)
#pragma config(Sensor, S4,     sonarSensor,         sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Brandeis lower-level robot move functions.
// use for both autonomous and teleop modes

void initializeDriveMotors()
{
  nMotorPIDSpeedCtrl[motorD] = mtrSpeedReg;  // enables motor speed regulation
  nMotorPIDSpeedCtrl[motorE] = mtrSpeedReg;
  nMaxRegulatedSpeed12V = 750;  // max regulated speed in degrees per second
}

void driveStop()
{
  motor[motorD] = 0;
  motor[motorE] = 0;
}

void driveContinuous(int speed)  // +speed forward; -speed backward
{
//  nSyncedMotors = synchDE; //motor D is the master, motor E is the slave
//  nSyncedTurnRatio = 100; //motors move at 100% alignment to each other

  motor[motorD] = speed; //turn motor D on, which controls motor E at the same power
  motor[motorE] = speed;
}

void driveDistance(int speed, int distance)  // +speed forward; -speed backward
{
//  nSyncedMotors = synchDE; //motor D is the master, motor E is the slave
//  nSyncedTurnRatio = 100; //motors move at 100% alignment to each other
  nMotorEncoder[motorD] = 0;
  nMotorEncoderTarget[motorD] = distance; //set motor's target position
  motor[motorD] = speed; //turn motor D on, which controls motor E at same power
  motor[motorE] = speed;
  while(nMotorRunState[motorD] != runStateIdle)//while motorB is not in an idle position
  {
   //continue to monitor nMotorEncoderTarget's target position
  }
  motor[motorD] = 0;  // turn the motors off.
//  nSyncedMotors = synchNone; //turn off motor synchronization
}

void turnRightLeft(int speed) //this works for either right or left, just change sign +/- of speed
{
  const int TURNCOUNT = 500; //change this value to get a proper turn
//  nSyncedMotors = synchDE; //motor D is the master, motor E is the slave
//  nSyncedTurnRatio = -100; //motors move at 100% alignment to each other, opposite directions
  nMotorEncoder[motorD] = 0;
  nMotorEncoderTarget[motorD] = TURNCOUNT; //set motor's target position
  motor[motorD] = speed; //turn motor D on, which controls motor E at same power
  motor[motorE] = speed;
  while(nMotorRunState[motorD] != runStateIdle)//while motorB is not in an idle position
  {
   //continue to monitor nMotorEncoderTarget's target position
  }
  motor[motorD] = 0;  // turn the motors off.
//  nSyncedMotors = synchNone; //turn off motor synchronization
}

void turnRight(int speed)
{
  turnRightLeft(speed);
}

void turnLeft(int speed)
{
  turnRightLeft(-speed);
}

void driveToBlackLine(int speed)
{
  int threshold = 44;

	while(SensorValue[lightSensor] > threshold)
	{
		driveContinuous(speed);
	}
  driveStop();
}

void driveToSonarOffset (int offset, int speed)
{
	while(SensorValue(sonarSensor) > offset)
	{
		driveContinuous(speed);
	}
  driveStop();
}

void driveToTouch (int speed)
{
	while(SensorValue(touchSensor) == 0)
	{
		driveContinuous(speed);
	}
  driveStop();
}

void testIRSeeker()
{
  while(1 == 1)
  {
//    if(SensorValue[IRSeeker2] == 5)
    {
      motor[motorD] = 25;
      motor[motorE] = 25;
    }

//    if(SensorValue[IRSeeker2] > 5)
    {
      motor[motorD] = -20;
      motor[motorE] = 20;
    }

//    if(SensorValue[IRSeeker2] < 5)
    {
      motor[motorD] = 20;
      motor[motorE] = -20;
    }
  }
}

void findThreshold()
{
  int lightValue;
  int darkValue;
  int sumValue;
  int thresholdValue;
  int countValue = 0;
  int lastSeen;

	while(SensorValue(touchSensor) == 0)
	{
		nxtDisplayStringAt(0,31,"Read Light Now");
	}

	lightValue = SensorValue(lightSensor);

	wait1Msec(1000);

	while(SensorValue(touchSensor) == 0)
	{
		nxtDisplayStringAt(0,31,"Read Dark Now");
	}

	darkValue = SensorValue(lightSensor);

	sumValue = lightValue + darkValue;
	thresholdValue = sumValue/2;
}

void lineFollow()
{
  float rpmD;
  float rpmE;
  long moveD;
  long moveE;
  while (true)
  {
    nMotorEncoder[motorD] = 0;
    nMotorEncoder[motorE] = 0;
    time1[T1] = 0;
    while (time1[T1] < 1000)
    {
      motor[motorD] = 100;
	    motor[motorE] = 10;
	    wait1Msec(10);
	    motor[motorD] = 10;
	    motor[motorE] = 100;
	    wait1Msec(10);
	  }
    moveD = nMotorEncoder[motorD];
    moveE = nMotorEncoder[motorE];
    rpmD = ((float) moveD) / 1440 * 60;
    rpmE = ((float) moveE) / 1440 * 60;
  }
}
